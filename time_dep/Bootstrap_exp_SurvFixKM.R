#Bootstrap Hypothesis Testing with censoring for time-dependent covariate

##Given data's survival time is generated when baseline distribution being exponential(1)
#Bootstrap sample's survival time is generated by inverse Breslow-type estimator for cumulative baseline hazard and smoothed by jitter function
#censoring time is generated by KM estimator

#H0: linear
#H1: monotone
#Test statistic T = difference between negative log partial likelihoods = l(psi_hat) - l(beta_hat)


source("C:/Users/Huan/Dropbox/0My research/codes/time_dependent/isoph_td.R")
source("C:/Users/Huan/Dropbox/0My research/codes/time_dependent/SurvTime_td.R")
source("C:/Users/Huan/Dropbox/0My research/codes/time_dependent/CenTimeFix_td.R")


Bootstrap_KMBS <- function(Z, hzrate, B, samp_size, k,qt, num_intervals){
  
#Generate the original sample
sig_level <- 0.05
tf <- FALSE #timefix

set.seed(k)



################################################################################
#Generating samples by the given hazard
#including survival time, censoring time, status.
################################################################################


U <- runif(samp_size, min = 0, max = 1)
neg_lnU <- -log(U) 

T_obs <- c(0.0001*seq(from = 0, to = num_intervals/2), 0.22*seq(from = 1, to = num_intervals/2))
#T_obs <- 0.001*seq(from = 0, to = num_intervals)#time intervals of length num_interval+1
T_obs[num_intervals+1] <- 1000
integral0 <- t(t(exp(hzrate))*diff(T_obs))#take transpose inside so we multiple each column by a number
T_survival <- c()


#survival time
for (rows in 1:samp_size) {
  integral1 <- cumsum(integral0[rows,])
  loc <- min(seq(num_intervals)[integral1> neg_lnU[rows]])#loc>=1
  
  if (loc > 1){
    T_survival[rows] <- (neg_lnU[rows] - integral1[loc-1])/exp(hzrate[rows,loc])+ T_obs[loc]
  }
  else
    T_survival[rows] <- neg_lnU[rows]/exp(hzrate[rows,loc])+ T_obs[loc]
}


#censoring time
if(qt > 0)
  T_censoring <- runif(samp_size, min = 0, max = quantile(T_survival, qt))
else
  T_censoring <- T_survival


OST <- pmin(T_survival, T_censoring)#observed survival time
Delta <- as.numeric(T_survival <= T_censoring)

hist(log(OST), main = paste0('log Original OST, n=', samp_size, 'k=',k))

#reshape the data to mimic the real dataset#####################################
Z_real <- list()
Start <- c()
End <- c()
Covariate <- c()
Status <- c()
n <- 1

for (rows in 1:samp_size){
  
  loc <- max(seq(num_intervals+1)[T_obs < OST[rows]])
  
  Z_real[[rows]] = Z[rows,1:loc]
  
  if(loc > 1){
    Start[n:(n+loc-1)] <- T_obs[1:loc]
    
    End[n:(n+loc-2)] <- T_obs[2:loc]
    End[n+loc-1] <- OST[rows]
    
    Status[n:(n+loc-2)] <- 0
    Status[n+loc-1] <- Delta[rows]
    
    Covariate[n:(n+loc-1)] <- Z[rows,1:loc]
  }
  
  else{
    Start[n] <- T_obs[1]
    
    End[n] <- OST[rows]
    
    Status[n] <- Delta[rows]
    
    Covariate[n] <- Z[rows,1]
  }
  
  n <- n+loc
  
}

MySimu<- data.frame("start" = Start, "end" = End, "covs" = Covariate, "event" = Status)



##observed value of test statistic##############################################
##Start from the first observed failure
################################################################################
sample_size <- dim(MySimu)[1]#update sample size
MySimu <- MySimu[order(MySimu$covs),]
location_start <- min(seq(sample_size)[MySimu$event > 0])
MySimu <- MySimu[location_start:sample_size,]


iso <- isoph_td(Start = MySimu$start, Stop = MySimu$end, Status = MySimu$event, Z = MySimu$covs)

psi_hat <- iso$psi.hat

mybeta <- iso$betahat

Tobs <- iso$ll_mono - iso$ll_linear



#Generate bootstrap sample######################################################
Tn <- c()

for (i in 1:B) {
  
  #survival time
  survgen <- SurvTime_td(beta = mybeta, OST = OST, Status = Delta, Z = Z_real, X = T_obs)
  survtime_B <- survgen$res
  
  #censoring time
  cengen <- CenTime_td(X= OST, Status = Delta, M=max(OST))
  centime_B <-cengen$res
  
  OST_B <- pmin(survtime_B, centime_B)#observed survival time
  
  hist(log(OST_B), main = paste0('log BT OST, k=', k,', n=100, B=',i))
  
  Delta_B <- as.numeric(survtime_B <= centime_B)
  
  #reshape the data
  Status_B <- as.numeric(survtime_B <= centime_B)
  X_B <- pmin(survtime_B, centime_B)
  
  Start_B <- c()
  End_B <- c()
  Covariate_B <- c()
  Status_B <- c()
  n <- 1
  
  for (rows in 1:samp_size){
    
    
    loc <- max(1, seq(num_intervals+1)[T_obs < OST_B[rows]])
    
    # cat(n,' & ', loc, ' \n')
    # if (loc <= 0 ){
    #   cat("haha")
    # }
    
    if(loc > 1){
      
      # wow_error <- 0
      # tryCatch( {  Start_B[n:(n+loc-1)] <- T_obs[1:loc]   } ,error = function(e){wow_error <<- 1 } )
      # if (wow_error){
      #   cat("catcha!")
      # }
     
      
      Start_B[n:(n+loc-1)] <- T_obs[1:loc]
      
      End_B[n:(n+loc-2)] <- T_obs[2:loc]
      End_B[n+loc-1] <- OST_B[rows]
      
      Status_B[n:(n+loc-2)] <- 0
      Status_B[n+loc-1] <- Delta_B[rows]
      
      lz <- length(Z_real[[rows]])
        
      if(loc > lz){
        Z_real[[rows]][(lz + 1 ): loc] <- Z_real[[rows]][lz]
      }
      
      Covariate_B[n:(n+loc-1)] <- Z_real[[rows]][1:loc]
      
    }
    
    else{
      Start_B[n] <- T_obs[1]
      
      End_B[n] <- OST_B[rows]
      
      Status_B[n] <- Delta_B[rows]
      
      Covariate_B[n] <- Z_real[[rows]][1]
    }
    
    n <- n+loc
    
  }
  
  MySimu_B <- data.frame("start" = Start_B, "end" = End_B, "covs" = Covariate_B, "event" = Status_B)
  
  ##Start from the first observed failure
  sample_size_B <- dim(MySimu_B)[1]#update sample size
  MySimu_B <- MySimu_B[order(MySimu_B$covs),]
  location_start <- min(seq(sample_size_B)[MySimu_B$event > 0])
  MySimu_B <- MySimu_B[location_start:sample_size_B,]
  
  #estimation
  iso_B <- isoph_td(Start = MySimu_B$start, Stop = MySimu_B$end, Status = MySimu_B$event, Z = MySimu_B$covs)
  
  #psi_hat <- iso_B$psi.hat
  
  
  Tn[i] <- iso_B$ll_mono - iso_B$ll_linear
}



T_critical <- quantile(Tn, sig_level)


results <- list(
  "T_obs" = Tobs,
  "T_n" = Tn,
  "beta_hat" = mybeta,
  "T_critical" = T_critical,
  "psi_hat" = psi_hat,
  "Z" = iso$Z,
  "p_value" = mean(as.numeric(Tn < Tobs)))

return(results)
}


